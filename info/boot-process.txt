*******************************************************************                                                                **                       THE BOOT PROCESS                         **                                                                ********************************************************************                                                                **      The following disassembly describes the boot process for  ** a slave disk.  In order to TRULY understand this listing, you  ** should first be familiar with the exact sequence and coding of ** disk bytes used in track formatting.  This information can be  ** found in chapter 3 of the book BENEATH APPLE DOS.  (The        ** distinctions between booting a slave disk versus a master disk ** are described in chapter 8 of the same reference.)             **      The boot process loads DOS into the machine as a series   ** of discrete packages.  After each package is loaded, it is     ** executed to load in the next section of DOS.  The last         ** instruction of the boot process jumps into DOS's coldstart     ** routine to build the DOS buffers, set up the page-three vector ** table and run the "HELLO" program.                             **      Because DOS is loaded in stages, any protected disk can   ** cracked by tracing the boot.  If you modify each section of    ** the boot to stop after loading the next section, you can       ** inspect the different stages of the boot to discover the       ** protection scheme(s) used.  (P.S.  In order to modify BOOT0,   ** you must first move it down to a RAM location defined by:      ** $hs00, where h = high nibble of an address that is low enough  ** to accomodate DOS in free memory above and, s = present slot   ** number housing the disk controller card.)                      **                                                                ********************************************************************::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::**                                                                **                        BOOT 0                                  **                                                                **----------------------------------------------------------------**                                                                ** - relocatable code resident on the disk controller's ROM.      ** - because the code is relocatable, the disk controllers card   **   can be used in different slots.  Execution begins at $Cs00,  **   where s = slot number (ex. $C600 for card in slot 6).        ** - When BOOT0 is executed it:                                   **       (1) builds a table of indices which are used to convert  **           the disk bytes into 6/2 encoded bytes which are      **           needed by RWTS to translate the disk bytes into      **           normal memory bytes.                                 **       (2) recalibrates the disk arm by moving it to trk0/sec0. **       (3) reads BOOT1 into $800 to $8FF (from trk0/sec0).      **       (4) jumps to $801 to begin the execution of BOOT1.       **                                                                **::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*(Cs00)BOOT0    LDX #$20     ;Controller card's identification byte.* Construct a read-translate table which* we will need to convert disk bytes to* encoded memory bytes.  (The encoded memory* bytes later go trough further decoding to* convert them to normal memory bytes.)** We construct the table by sequentially* incrementing (x) and testing it to see* if it meets the folowing criteria of a* disk byte:*   (1) it must have at least one pair of*       adjacent 1's in bits 0 to 6.*   (2) it must not have more than one pair*       of adjacent 0's in bits 0 to 6.* (Note that we use the x-value to represent* only the lower seven bits of a disk byte* because all disk bytes are negative.)** Each time we find an (x) that represents* a simulated disk byte, we increment (y).* (Y) is then placed in the read table at an* offset of (x) from the beginning of the table.* The table generated is shown below.  The* empty bytes represent offsets where (x)* did not meet the criteria of a disk byte.* The values in parentheses represent the* (x)-values tested.*      36C-    00   01   --   --*             (16) (17) (18) (19)*      370-    02   03   --   04   05   06   --  --*             (1A) (1B) (1C) (1D) (1E) (1F) (20) (21)*      378-    --   --   --   --   07   08   --   --*             (22) (23) (24) (25) (26) (27) (28) (29)*      380-    --   09   0A   0B   0C   0D   --   --*             (2A) (2B) (2C) (2D) (2E) (2F) (30) (31)*      388-    0E   0F   10   11   12   13   --   14*             (32) (22) (34) (35) (36) (37) (38) (39)*      390-    15   16   17   18   19   1A   --   --*             (3A) (3B) (3C) (3D) (3E) (3F) (40) (41)*      398-    --   --   --   --   --   --   --   --*             (42) (43) (44) (45) (46) (47) (48) (49)*      3A0-    --   1B   --   1C   1D   1E   --   --*             (4A) (4B) (4C) (4D) (4E) (4F) (50) (51)*      3A8-    --   1F   --   --   20   21   --   22*             (52) (53) (54) (55) (56) (57) (58) (59)*      3B0-    23   24   25   26   27   28   --   --*             (5A) (5B) (5C) (5D) (5E) (5F) (60) (61)*      3B8-    --   --   --   29   2A   2B   --   2C*             (62) (63) (64) (65) (66) (67) (68) (69)*      3C0-    2D   2E   2F   30   31   32   --   --*             (6A) (6B) (6C) (6D) (6E) (6F) (70) (71)*      3C8-    33   34   35   36   37   38   --   39*             (72) (73) (74) (75) (76) (77) (78) (79)*      3D0-    3A   3B   3C   3D   3E   3F   --   --*             (7A) (7B) (7C) (7D) (7E) (7F)(Cs02)   LDY #0       ;Initialize the (y) index.(Cs04)   LDX #3       ;"3" is used for controller ID.  Any number                      ;between 0 and #$16 could be used.  Except                      ;for ID purposes, the operand isn't even                      ;relevant until it is #$16 (dec #22).BUILDTBL STX BT0SCRTH ;Save potential index seed in the zero page.(Cs06)* Transfer (x) to (a) and test to see if it* meets the following disk byte criteria:*  (1) has at least one pair of adjacent 1's*      in bits 0 to 6.*  (2) has no more than one pair of adjacent*      0's in bits 0 to 6.* Test for adjacent 1's.** Note:  by comparing a shifted version of* the seed (in accumulator) with the original* version of the seed (in BT0SCRTH, $3C) we are* actually testing adjacent bits as shown below:*        Shifted:  b6   b5   b4   b3   b2   b1  b0   0*        Orignal:  b7   b6   b5   b4   b3   b2  b1  b0*                  -----------------------------------*        Testing: b6,7 b5,6 b4,5 b3,4 b2,3 b1,2 b0,1 -(Cs08)   TXA         ASL(Cs0A)   BIT BT0SCRTH ;Conditions the z-flag of the status.                      ;(If any bits match, z-flag=1.)(Cs0C)   BEQ GETNEWX  ;Branch if value was illegal.                      ;Illegal value = z-flag=1 = no match = no                      ;adjacent 1's.* Got at least 1 pair of adjacent 1's, so* now prepare to test for adjacent 0's.* (Note:  the previous "BIT" instruction* alters the z-flag in the status but* does not affect the accumulator.)(Cs0E)   ORA BT0SCRTH ;Merge shifted version of seed with orig.(Cs10)   EOR #$FF     ;Take 1's compliment of shifted version to                      ;swap 1's for 0's and 0's for 1's.(Cs12)   AND #%01111110 ;Throw away the hi and least significant                      ;bits so will be testing:                      ;    b5,6  b4,5  b3,4  b2,3 b1,2 b0,1.* Test for pairs of adjacent 0's.* Remember, only 1 pair of adjacent 0's is* allowed.  Because we did a 1's compliment* of the merged bits above, a SET BIT NOW* DENOTES A PAIR OF ADJACENT 0's.  We can* therefore test for a pair of adjacent 0's* by shifting a bit into the carry:*  - if (c) = 1 = at least one pair of adjacent 0's*    is present.*  - if (c) = 1 AND the remaining byte = 0 then*    we have only one pair of adjacent 0's so*    value is legal.*  - if (c) = 1 AND the remaining byte < > 0, we*    have more than one pair of adjacent 0's so*    value is illegal.(Cs14)TESTCARY BCS GETNEWX  ;Always fall through on very first entry.                      ;If branch is taken, got illegal value                      ;because more than 1 pr of adjacent 0's.(Cs16)   LSR          ;Shift a bit into the carry (if carry set                      ;have at least 1 pr of adjacent 0's).(Cs17)   BNE TESTCARY ;Take branch when remaining byte is not                      ;zero.  Got at least 1 pr of adjacent 0's.                      ;Go test carry to see if another pair has                      ;already been detected.* Index byte was legal.  We either got no* adjacent 0's or else only one pair of* adjacent 0's.(Cs19)   TYA          ;Store the counter that corresponds to a(Cs1A)   STA BTNIBL-$16,X ;legal nibble.  The first (x) value used                      ;is #$16, last is #$7F.  The first (y) value                      ;stored is 0, the last is #$3F.(Cs1D)   INYGETNEWX  INX(Cs1F)   BPL BUILDTBL ;Keep on trying to build table until (x)                      ;increments to #$80.* Find out which slot the disk controller* card resides in.(Cs21)   JSR MONRTS   ;Jsr to an RTS to put the present address on                      ;the stack.  The hi byte of the present addr                      ;($Cs) tells us what slot (s) the card is                      ;located in.                      * An RTS instruction in monitor ROM.                      (FF58)                      MONRTS   RTS(Cs24)   TSX          ;Put the value of the stack pointer in (x).(Cs25)   LDA STACK,X  ;Get the hi byte of the controllers address                      ;($Cs) from the stack.(Cs28)   ASL          ;Multiply by 16 (throwing away original hi         ASL          ;nibble) so we are left with #$s0.         ASL         ASL          ;(a) = slot * 16.         STA SLT16ZPG ;Save slot*16 in a zero-page location.(Cs2E)   TAX          ;Set (x) = slot * 16 so we can index the                      ;base addresses associated with the drive                      ;functions.(Cs2F)   LDA Q7L,X    ;Set the READ mode.         LDA Q6L,X         LDA SELDRV1  ;Select drive 1.(Cs38)   LDA MTRON,X  ;Spin the disk.* Move disk arm to track 0 by doing a* recalibration.  (That is, force the arm* against the stop by pretending that it* is presently at trk decimal 40.)* (The arm is moved by sequentially turning* a series of magnets off and on.)(Cs3B)   LDY #80      ;Pretend arm is at trk40 (dec 80 half-trks).MAGNTOFF LDA MAG0FF,X ;Turn the presently aligned magnet off.(Cs40)   TYA          ;Calculate the next magnet that should be                      ;turned on to suck the arm over.(Cs41)   AND #%00000011 ;Only keep the lower two bits because we                      ;only want a maximum value of 3 because                      ;there are only 4 magnets (which are indexed                      ;by values 0 to 3).  The sequence used in                      ;this loop is: 3,2,1,0,3...(Cs43)   ASL          ;Multiply by 2 so the index is directed to                      ;an address that turns a magnet ON.  The                      ;sequence used is:  6,4,2,0,6...0.(Cs44)   ORA SLT16ZPG ;Merge the index with the slot * 16 value.         TAX          ;Put the calculated index in (x).         LDA MAG0N,X  ;Turn the appropriate magnet ON.(Cs4A)   LDA #$56     ;Delay approximately 20 000 machine cycles                      ;(approximately 20 milliseconds.)  (Gives (Cs4C)   JSR WAIT     ;arm time to align with energized magnet                      ;and reduces overshoot or bounce.)                      * Monitor ROM's main delay routine.                      * Delay z number of cycles based on                      * the formula:                      *    z = ((5 * a^2) + (27 * a) +26) / 2                      *    where a = value in the accumulator on entry.                      (FCA8)                      WAIT     SEC          ;Prepare for subtraction.                      WAIT2    PHA          ;Save (a) on the stack.                      WAIT3    SBC #1       ;Keep on reducing (a) until it equals 0.                               BNE WAIT3                               PLA                               SBC #1       ;Reduce the original (a) down to 0 again.                               BNE WAIT2                      (FCB3)   RTS(Cs4F)   DEY          ;Reduce trk # count.(Cs50)   BPL MAGNTOFF ;Not at trk0 yet, so go move arm some more.* Initialize the buffer pointer and trk/sec values.* (On entry:  (x) = slot *16, (y) = #$FF & (a) = $00.)(Cs52)   STA PT2BTBUF ;Set the low byte of the buf pointer to $00.         STA BOOTSEC  ;Initialize for sector 0 on track 0.         STA BOOTRK         LDA #8       ;Set the hi byte of the buf pointer to $08(Cs5A)   STA PT2BTBUF+1 ;(that is, direct pointer at $800).* Prepare to start reading a prologue.(Cs5C)BTRDSEC  CLC          ;(c) = 0 = signal to read an addr prologue.* Begin reading a prologue.(Cs5D)PRSRVFLG PHP          ;Preserve the status denoting if reading                      ;address ((c)=0) or data ((c)=1) prologue.* Look for an address prologue ("D5 AA 96")* or a data prologue ("D5 AA AD").(Cs5E)STARTSEQ LDA Q6L,X    ;Read a disk byte.         BPL STARTSEQ ;Wait for a full byte.BTRYD5   EOR #$D5     ;Is it a "D5"?         BNE STARTSEQ ;No - restart sequence.BTRYAA   LDA Q6L,X    ;Read next byte in header.         BPL BTRYAA   ;Wait for a full byte.         CMP #$AA     ;Is it an "AA"?         BNE BTRYD5   ;No - restart sequence.         NOP          ;Delay 2 cycles.BTRY96   LDA Q6L,X    ;Read third byte in header.         BPL BTRY96   ;Wait for a full byte.         CMP #$96     ;Is it a "96"?Cs78)    BEQ RDVLTKSC ;Found an address prologue, so now go read                      ;the vol, trk, sec values in the header.* The first two bytes were "D5 AA".* The 3rd byte was not "96".  Therefore,* although we know this isn't an address* prologue, maybe it is a data prologue.(Cs7A)   PLP          ;Get the status back off the stack so we can                      ;check if we were looking for an address or                      ;data prologue.(Cs7B)   BCC BTRDSEC  ;Branch back to try again if we were looking                      ;for an address prologue but didn't find it.* We were looking for a data prologue so* now compare the 3rd byte with that of a* data prologue.(Cs7D)BTRYAD   EOR #$AD     ;Is it an "AD"?         BEQ RDBTDATA ;Yes - found data prol so now read in data.(Cs81)   BNE BTRDSEC  ;No - go try again to find sequence 4 data.* Read volume, track and sector values in* the address header.* Remember, @ of these pieces of information* are housed in two bytes in an odd-even encoded* format:   1rst byte:   1 b7  1 b5  1 b3  1 b1  (odd-encoded).*            2nd byte:   1 b6  1 b4  1 b2  1 b1  (even-encoded).* We must decode these bytes to check if we located* the correct volume, track and sector.(Cs83)RDVLTKSC LDY #3       ;Set counter for 3 decoded bytes.MOREBYTS STA BOOTEMP  ;Only relevant the last time through the(Cs85)                ;loop at which time it contains the decoded(Cs87)                ;track number read off the disk.BTRDODD  LDA Q6L,X    ;Read odd-encoded byte.         BPL BTRDODD  ;Wait for a full byte.(Cs8C)   ROL          ;Throw away the hi bit & shift the odd bits                      ;to their regular position.(Cs8D)   STA BT0SCRTH ;Save realigned version of odd-encoded byte.BTRDEVEN LDA Q6L,X    ;Read the even-encoded byte.         BPL BTRDEVEN ;Wait for a full byte.         AND BT0SCRTH ;Merge the two bytes.         DEY          ;Reduce counter for # of bytes to rebuild.         BNE MOREBYTS ;Branch if more bytes to patch back together.         PLP          ;Throw the status on the stack away.         CMP BOOTSEC  ;Is the sector read = sector wanted?         BNE BTRDSEC  ;No - go back to find correct sector.         LDA BOOTEMP  ;Get decoded trk # just read off disk.         CMP BOOTRK   ;Is trk found = trk wanted?         BNE BTRDSEC  ;No - go back to try again.(CsA4)   BCS PRSRVFLG ;ALWAYS - just read addr field, so now go                      ;         read the data prologue.* Read the sector's data bytes.* Read the first 86 ($56) bytes of the sector.  Use* the disk byte as an index to the BTNIBL table ($36C-$3D5).* Get the value from BTNIBL table & EOR it with the* previous EOR result (except on entry, use* #0 EOR BTNIBL-$96,Y) to produce a 2-encoded nibble.* (On entry, (a) = 0.)(CsA6)BTRDATA  LDY #$56     ;Read $56 (dec #86) bytes.KEEPCNT1 STY BT0SCRTH ;Save the counter.RDDSK1   LDY Q6L,X    ;Read a disk data byte.         BPL RDDSK1   ;Wait for a full byte.(CsAF)   EOR BTNIBL-$96,Y ;Use disk byte as an index to the table                      ;and EOR to decode to a 2-encoded nibble.(CsB2)   LDY BT0SCRTH ;Retrieve the counter.         DEY          ;Reduce the counter (& condition z-flag).         STA BUF300,Y ;Store 2-encoded nibble in page 3 buffer.(CSB8)   BNE KEEPCNT1 ;Branch if more bytes to read.* Read the rest of the sector (256 disk bytes* remaining).  Use disk byte as an index to BTNIBL* table.  Get value from nibble table and EOR it* with previous EOR result to yeild a 6-encoded* nibble.  (On entry, (y) = 0.)(CsBA)KEEPCNT2 STY BT0SCRTH ;Set disk byte counter = 0.RDDSK2   LDY Q6L,X    ;Read a disk byte.         BPL RDDSK2   ;Wait for a full byte.(CsC1)   EOR BTNIBL-$96,Y ;Use disk byte as an index to the nibble                      ;table and EOR it with previous result to                      ;produce a 6-encoded nibble.(CsC4)   LDY BT0SCRTH ;Get index to buffer.         STA (PT2BTBUF),Y ;Store 6-encoded nibble in buffer.         INY          ;Kick up offset into buffer.(CsC9)   BNE KEEPCNT2* Read and test the data checksum.* On entry, (a) = result of previous cummulative* EORing.  Therefore, any non-cancelling errors are* detected at the BNE instruction below.(CsCB)RDCK     LDY Q6L,X    ;Read the data checksum.         BPL RDCK     ;Wait for a full byte.(CsD0)   EOR BTNIBL-$96,Y ;EOR byte read with the previous                      ;cummulative result.TSTRERD  BNE BTRDSEC  ;Bad checksum so branch back to re-read.(CsD3)                ;(Also branches to here if got a good read                      ;but there are more sectors to read if the                      ;first byte of BOOT1 is modified to allow                      ;BOOT0 to read more than 1 sector (see                      ;comments below).* Convert 6-and-2 encoded buffer bytes to* normal 8-bit memory bytes.(CsD5)   LDY #0       ;Initialize index to target memory byte.SETX56   LDX #$56     ;Set index to buf containing encoded bytes.DOWNX    DEX          ;Reduce index for next buffer byte.         BMI SETX56   ;Reset index to encoded buffer.         LDA (PT2BTBUF),Y ;Get (a) = 6-encoded nibble.         LSR BUF300,Y ;Put a bit from the 2-encoded buffer in (c)         ROL          ;and then roll it into the 6-encoded nibble.         LSR BUF300,Y ;Do the same with the next bit of the pair.         ROL         STA (PT2BTBUF),Y ;Store the re-constructed 8-bit byte in memory.         INY          ;Increase the offset to the buffer.(CsE9)   BNE DOWNX    ;Branch back if more bytes to reconstruct.* Prepare to read in the next sector.* NOTE:  Normaly only trk0/sec0 (which* represents BOOT1) is read in by BOOT0.* The number of sectors read in by BOOT0 is* determined by the first byte of BOOT1.* Whereas BOOT1 resides in memory on an 48K* INITed disk at $B600 - $B6FF, we can zap a* disk at $B600 with the # of sectors we * we would like BOOT0 to read in if we want* it to read in more than 1 sector.(CsEB)   INC PT2BTBUF+1 ;Just crossed page boundary, so kick up                      ;the hi byte of the target address.(CsED)   INC BOOTSEC  ;Set value for next sector wanted.         LDA BOOTSEC  ;Get next sector wanted.(CsF1)   CMP $800     ;Test if read enough sectors.                      ;First byte of image of BOOT1 normally                      ;contains #$01 which denotes only 1 sector                      ;(sec0/trk0) should be read in by BOOT0.(CsF4)   LDX SLT16ZPG ;(x) = slot *16.         BCC TSTRERD  ;Branch back to read more sectors.(CsF8)   JMP BT1EXC08 ;Jumps into BOOT1 (which was copied into         ------------ ;page 8 from trk0/sec0) to begin execution                      ;of BOOT1.*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::**                                                                **                        BOOT 1                                  **                                                                **----------------------------------------------------------------**                                                                ** - stored on trk0/sec0.                                         ** - IMAGE in memory on a 48K system resides at $B600 - $B6FF.    ** - read into $800 to $8FF by the disk controller ROM (BOOT0).   ** - execution begins at $801 & uses the controller's read sector **   subroutine (BTRDSEC, Cs00, where s = slot # of card) to read **   in trk0/sec9 down to trk0/sec1 ($BFFF --> $B600).            ** - NOTE:  In order to generate an accurate symbol table that    **   can be applied 2 both the formatted & linear disassemblies,  **   and because different assemblers vary in their abilities to  **   accept certain OBJect values or re-ORG during assembly, the  **   following special label system has been created:             **   Image label/adr   Execution label/adr         Comments       **   ---------------   -------------------   -------------------- **   SEC2RDB6, $B600    SEC2RD08, $800      ;Defines # of secs to **                                          ;be read in by boot0. **   BT1EXCB6, $B601    BT1EXC08, $801      ;Start of boot1.      **                                          ;Boot0 jumps to this  **                                          ;location.            **   SKPRELB6, $B61F    SKPREL08, $81F      ;Target labl 4 brnch. **   PRP4B2B6, $B639    PRP4B208, $839      ;Target labl 4 brnch. **     IMG8FD, $B6FD    BT1LDADR, $8FD      ;Boot1 load address.  **                                          ;Varies from $B600 to **                                          ;$BF00.  Eventually   **                                          ;pts 2 start of boot2 **                                          ;($B700).             **     IMG8FF, $B6FF    BT1PG2RD, $8FF      ;Contains # of secs 2 **                                          ;be read in when      **                                          ;executing boot1. Also**                                          ;doubles as logical   **                                          ;sec #. Varies from:  **                                          ;$09 --> $00 --> $FF. ** - As indicated above, SEC2RD08 ($800) defines the number of    **   sectors to be read in by boot0.  This value is normally $01  **   (meaning read only sector0 of track0).  However, you can zap **   trk0/sec0/offset0 with a larger value ($01 to $10) to read   **   more sectors from trk0.  Also note that most references say  **   that SEC2RD08 normally contains a "$00" (rather than a       **   "$01").  Because the test at $CsF6 uses the carry, either    **   value will only cause one sector to be read in.  However,    **   "$01" is the value used by DOS.  (Confusion may stem from    **   the fact that Applesoft later stores a $00 in memory at      **   $800.)                                                       **                                                                **::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*(B600)  <============= image address.SEC2RDB6(800)  <============== execution address.SEC2RD08 HEX 01       ;Defines the number of sectors to be read                      ;in from track 0 during BOOT0.(B601)BT1EXCB6(801)BT1EXC08 LDA PT2BUF+1 ;Get the next page to read in.         CMP #$09     ;Is it page 9 (ie. first page read by BOOT1)?         BNE SKPREL08 ;No - already used by BOOT1 to read page 9,                      ;so skip pointer initialization given below.* Initialize the pointer (PT2RDSC) to point* at BOOT0's read sector subroutine (BTRDSEC,* $Cs5C, where s = slot #, normally $C65C).(B607)(807)    LDA SLT16ZPG ;(a) = slot *16.         LSR          ;Divide by 16.         LSR         LSR         LSR         ORA $C0      ;Merge with $C0 to get $Cs, where s=slot#.         STA PTR2RDSC+1 ;Store the hi byte of the address of the                      ;controller's read sector subroutine.         LDA #<BTRDSEC ;Get low byte of addr of subroutine.         STA PTR2RDSC ;Low byte is a constant (#$5C) and is                      ;therefore not variable with the slot used                      ;(as is the hi byte).* Read in the 9 sectors represented by* trk0/sec9 down to trk0/sec1 into* $BFFF to $B600.  Note that the sectors* are read in from higher to lower memory.* These sectors contain the IMAGE of BOOT1,* part of the File Manager and almost all* of RWTS and it's associated routines.* Calculate target address for the first sector* to be read in.(B615)(815)    CLC         LDA BT1LDADR+1 ;Contains $B6 on 48K slave.         ADC BT1PG2RD ;Contains #$09 on 48K slave.         STA BT1LDADR+1 ;(a) = #$BF on 48K slave.* Determine the number of sectors left to read,* the physical sector number & the target address.* Then, go read in the next sector.(B61F)SKPRELB6(81F)SKPREL08 LDX BT1PG2RD ;(x) = pages left to read in less 1.                      ;(Also doubles as logical sector number.                      ;Varies from $09 --> $FF.)         BMI PRP4B208 ;When (x) = $FF, we have read all the                      ;sectors in so go exit.         LDA PHYSECP8-$AE00,X ;Convert the logical sector number                      ;to a physical sector number. (Equivalent                      ;to "LDA $84D,X".)         STA BOOTSEC  ;Store physical sector number in page0.         DEC BT1PG2RD ;Reduce sectors (pages) left to read for                      ;the next time around.         LDA BT1LDADR+1 ;Point the buffer pointer at the target         STA PT2BTBUF+1 ;address. (Varies from $BF to $B6 on a                      ;48K slave.)         DEC BT1LDADR+1 ;Reduce the hi byte of the I/O buffer for                      ;the next time around. (Varies from $BF to                      ;$B5 on a 48K slave.)         LDX SLT16ZPG ;Set (x) = slot*16.(836)    JMP (PTR2RDSC) ;Equivalent to "JMP ($8FD)" or "JMP $Cs5C"(B636)   ------------ ;to go read in the next sector.                      ;***************** NOTE *******************                      ;* GOES TO BT1EXC08 ($801) AFTER @ SECTOR *                      ;* IS READ IN. (BT1EXCB6 is a carbon copy *                      ;* of BT1EXC08.)                          *                      ;******************************************* Prepare for BOOT2.(B639)PRP4B2B6(839)PRP4B208 INC BT1LDADR+1 ;Point at the load address for BOOT2.         INC BT1LDADR+1 ;(After the INCs = $B7 on 48K slave.)* Set full screen text & designate the* keyboard and screen as the I/O devices.(B63F)(83F)    JSR SETKBD   ;Simulate an IN#0.  (See dis'mbly below.)         JSR SETVID   ;Simulate an PR#0.  (See dis'mbly below.)         JSR INIT     ;Simulate a "TEXT" statement. (See dis'mbly                      ;in APPLE II REFERENCE MANUAL at $FB2F.)         LDX SLT16ZPG ;(x) = slot * 16.     * Go to BOOT2.(B64A)(84A)    JMP (BT1LDADR) ;Jump to BOOT2 ($B700 on 48K slave).         --------------*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::**                                                                **                       BOOT2                                    **                                                                **----------------------------------------------------------------**                                                                ** - Reads in the rest of DOS starting at trk02/sec04 down to     **   trk00/sec0A ($B5FF --> $9B00).  (P.S. Sectors 0A and 0B of   **   track 0 are empty ($9CFF - $9B00).)                          ** - After the rest of DOS is read in, execution jumps to DOS's   **   coldstart routine (DOSCLD, $9D84).                           ** - Note that on entry:  (x) = slot * 16                         **                                                                **::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::** Prepare RWTS's input-output block (IOB)* and designate the number of sectors to read.(B700)BOOT2    STX IBSLOT   ;(x) = slot*16 wanted.         STX IOBPSN   ;Last-used slot*16 value.         LDA #1       ;Set both the last-used and wanted drives         STA IOBDPDN  ;as drive #1.         STA IBDRVN         LDA NMPG2RD  ;Set number of pages (ie. secs) to read.         STA BT2PGCTR ;Counter for for number of pages to read.         LDA #2       ;Start with trk02/sec04.         STA IBTRK    ;Track.         LDA #4         STA IBSECT   ;Sector.(B71E)   LDY BT1MGADR+1 ;(y) = hi byte of the address of the image                      ;of BOOT1 (#$B6 on a 48K slave).(B721)   DEY          ;Define I/O buf as 1 page below boot1.         STY IBBUFP+1         LDA #1       ;Opcode for read.(B727)   STA IBCMD* Convert from (x) = slot*16 to (x) = slot.(B72A)   TXA          ;(x) = slot * 16.         LSR          ;Divide by 16.         LSR         LSR         LSR(B72F)   TAX          ;(x) = slot.* Initialize the page-four locations with* the track numbers associated with the drives.(B730)   LDA #0         STA TRK4DRV2,X(B735)   STA TRK4DRV1,X* Call the routine to read in the rest of DOS.(B738)   JSR RWPAGES                      * READ/write a group of pages.                      (B793)                      RWPAGES  LDA ADROFIOB+1 ;Init (a)/(y) with the hi/low bytes of the                               LDY ADROFIOB ;addr of RWTS's IOB for entry to RWTS.                      (B799)   JSR ENTERWTS ;Enter RWTS to read/write sector.                                            * Entry to RWTS.                                            (B7B5)                                            ENTERWTS PHP          ;Save status register on the stack.                                            (B7B6)   SEI          ;Set the interrupt disable flag to prevent                                                                  ;any further maskable interrupts when doing                                                                  ;real-time programming.                                            (B7B7)   JSR RWTS     ;Enter RWTS proper to do the operation:                                                                  ; $00=seek, $01=read, $02=write, $03=format.                                                                  * RWTS proper.                                                                  (BD00)                                                                  RWTS     .                                                                           .                                                                  (See dis'mbly in RWTSDRVR using READ.)                                                                           .                                                                           .                                                                           (RTS)                                            (B7BA)   BCS ERRENTER ;Operation was NOT successful.                                                     PLP          ;Retrieve saved status off the stack.                                            (B7BE)   RTS                                                     ============                                            (B7BF)                                            ERRENTER PLP          ;Throw the saved status off the stack.                                                     SEC          ;Signal operation was unsuccessful.                                            (B7C1)   RTS                                                     ============                      (B79C)   LDY IBSECT   ;Get # of the sector just read or written.                      (B79F)   DEY          ;Set value for next sector 2 read.  When                                            ;executing BOOT1, goes from $09 to $FF.                      (B7A0)   BPL SAMETRK  ;Branch to use the same track.                      * Start a new track.                      (B7A2)   LDY #$0F     ;Start with sector 15.                               NOP                               NOP                      (B7A6)   DEC IBTRK    ;Reduce number of track wanted.                      * Reduce the addr of the target memory location.                      * Test if more sectors to read.                      (B7A9)                      SAMETRK  STY IBSECT   ;Store the sector wanted.                               DEC IBBUFP+1 ;Reduce buf addr of target memory location.                               DEC BT2PGCTR ;Reduce counter for # of sectors to read.                               BNE RWPAGES  ;More sectors to read.                      (B7B4)   RTS(B73B)   LDX #$FF     ;Completely clear out the stack.         TXS         STX IBVOL    ;Set the volume to $FF (compliment of 0).(B741)   JMP CLOBCARD         ------------* Patch to clobber the language card* and set video output.(BFC8)CLOBCARD JSR SETVID   ;Select the video screen.                      * Monitor ROM's routine to designate the                      * video screen as the output device.                      * (Simulate a "PR#0" statement.)                      (FE93)                      SETVID   LDA #0       ;Designate slot 0.                      OUTPORT  STA A2L                      OUTPRT   LDX #<CSW    ;Set offset from start of zero page to OUTPUT hook.                               LDY #<COUT1                      IOPRT    LDA A2L                               AND #$0F                      (FE9F)   BEQ IOPRT1   ;ALWAYS.                      (FEA7)                      IOPRT1   LDA #>COUT1  ;(Hi byte of addr of KEYIN & COUT1 are equal.)                      IOPRT2   STY LOC0,X   ;Set CSW: COUT1.                               STA LOC1,X                      (FEAD)   RTS(BFCB)   LDA $C081    ;Write enable the RAM card.         LDA $C081    ;(Read motherboard / write card bank 2.)         LDA #0       ;Set the language identifying byte on the(BFD3)   STA BASICCLD ;card to $00 so if card is tested (during                      ;an FP command), the machine will be forced                      ;to use the motherboard version of FP.(BFD6)   JSR CONTCLOB ;Now clobber the 80-column card.                      * Clobber the 80-column card.                      (BA76)                      CONTCLOB LDA #$FF     ;Set the mode flag for card.                               STA $4FB     ;Scratch pad memory for slot 3 peripheral.                               STA $C00C    ;Turn off the alternate character set.                               STA $C00E                      (BA81)   JMP INIT     ;Simimulate a TEXT statement.                               ------------                      * Monitor ROM's Init routine.                      (FB2F)                      INIT     .                               .                      (See dis'mbly in APPLE II REFERENCE MANUAL.)                               .                               .                      - simulate a text statement.                        (Ie. set window to full screen text.)                               .                               .                               (RTS)(BFD9)   JMP BK2BOOT2 ;Return to original part of BOOT2.         ------------* Return back to original part of BOOT2.(B744)BK2BOOT2 JSR SETKBD   ;Select the keyboard.                      * Monitor ROM's routine to designate the                      * keyboard as the input device.                      * (Simulate a "IN#0" statement.)                      (FE89)                      SETKBD   LDA #0       ;Pretend using slot 0.                      INPORT   STA A2L                      INPRT    LDX #<KSW    ;Set offset from start of zero page to INPUT hook.                               LDY #<KEYIN                      (FE91)   BNE IOPRT    ;ALWAYS.                      (FE9B)                      IOPRT    LDA A2L                               AND #$0F                      (FE9F)   BEQ IOPRT1   ;ALWAYS.                      (FEA7)                      IOPRT1   LDA #>COUT1  ;(Hi byte of the addr of KEYIN & COUT1 are equal.)                      IOPRT2   STY LOC0,X   ;Set KSW: KEYIN.                               STA LOC1,X                      (FEAD)   RTS(B747)   JMP DOSCOLD  ;Jump into DOS's coldstart routine to build         ------------ ;the DOS buffers and the page-three vector         .            ;table and then run the "HELLO" program.         .            ;*************** N O T E *****************         .            ;* This instruction is a hacker's dream. *         .            ;* For instance, you can change the jump *         .            ;* to point to you own password or time- *         .            ;* bomb routine that you have deviously  *         .            ;* embedded in an unused section of DOS. *         .            ;*****************************************         .         .         .*---------------------** SEE dis'mbly titled **    "DOSCOLDSTART"   **---------------------*         .         .         .